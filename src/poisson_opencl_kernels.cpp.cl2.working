//
// auto-generated by ops.py//

//header
#define OPS_API 2
#define OPS_2D
#include "stdlib.h"
#include "stdio.h"
//#include "ops_lib_cpp.h"
#include "../ops/c/include/ops_lib_cpp.h"
//#include "ops_opencl_rt_support.h"
#include "../ops/c/include/ops_opencl_rt_support.h"
#include "OpenCL/user_types.h"
#include "xcl2.hpp"


#include <vector>

using std::vector;
static bool isbuilt_poisson_kernel_populate = false;

typedef struct {
	//cl_platform_id *platform_id;
	//cl_device_id device_id;
	//cl_device_id *devices;
	//cl_uint n_devices;
	//cl_uint n_platforms;
	//cl_command_queue command_queue;
	cl::CommandQueue command_queue;
	vector<cl::Kernel> kernel;
	//cl_kernel *kernel;
	//cl_program program;
	cl::Program program;
	//cl_context context;
	cl::Context context;
	cl_uint n_kernels;
	//cl_mem *constant;
	//cl::Memory **constant;
	cl::Buffer constant[2];
	//vector<cl::Buffer> constant;

	cl_uint n_constants;
	// cl_mem *data_d; // cl_mem struct corresponding to ops_core_dat char* data_d
} ops_xcl_core;





#ifdef OCL_FMA_SWITCH_ON
#define OCL_FMA 1
#else
#define OCL_FMA 0
#endif
//global constants
extern double dx;
extern double dy;

//extern ops_opencl_core OPS_opencl_core;
ops_xcl_core OPS_xcl_core;


//cl::Kernel krnl[5];


int load_file_to_memory(const char *filename, char **result)
{
	uint size = 0;
	FILE *f = fopen(filename, "rb");
	if (f == NULL) {
		*result = NULL;
		return -1; // -1 means file opening fail
	}
	fseek(f, 0, SEEK_END);
	size = ftell(f);
	fseek(f, 0, SEEK_SET);
	*result = (char *)malloc(size+1);
	if (size != fread(*result, sizeof(char), size, f)) {
		free(*result);
		return -2; // -2 means file reading fail
	}
	fclose(f);
	(*result)[size] = 0;
	return size;
}

void ops_init_backend() {
	//OPS_xcl_core.constant.resize(2);
}
bool const0_set = false;
bool const1_set = false;
//this needs to be a platform specific copy symbol to device function
void ops_decl_const_char( int dim, char const * type, int typeSize, char * dat, char const * name ) {
	//cl_int ret = 0;
	ops_printf("ops_decl_const_char OOOOOO \n");
	cl_int err = 0;

/*	if (OPS_xcl_core.constant == nullptr) {
		//OPS_xcl_core.constant = (cl_mem*) malloc((2)*sizeof(cl_mem));

		OPS_xcl_core.constant = (cl::Buffer*) malloc((2)*sizeof(cl::Buffer));
		for ( int i=0; i<2; i++ ){
			//OPS_xcl_core.constant[i] = nullptr;
		}
	}*/

	if (!strcmp(name,"dx")) {

		//if (OPS_xcl_core.constant[0] == 0) {
		if (!const0_set){
			/*OPS_opencl_core.constant[0] = clCreateBuffer(OPS_opencl_core.context, CL_MEM_READ_WRITE, dim*typeSize, &d_bank0_ext, &ret);
			clSafeCall( ret );*/
			//OCL_CHECK(err, OPS_xcl_core.constant[0] = cl::Buffer(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, dim*typeSize, nullptr));
			OCL_CHECK(err, OPS_xcl_core.constant[0] = cl::Buffer(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, dim*typeSize, (void*) dat));
			const0_set = true;
		}

		//Write the new constant to the memory of the device

		/*clSafeCall( clEnqueueWriteBuffer(OPS_xcl_core.command_queue, OPS_xcl_core.constant[0], CL_TRUE, 0, dim*typeSize, (void*) dat, 0, NULL, NULL) );
		clSafeCall( clFlush(OPS_xcl_core.command_queue) );
		clSafeCall( clFinish(OPS_xcl_core.command_queue) );*/

		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.enqueueMigrateMemObjects({OPS_xcl_core.constant[0]},0/* 0 means from host*/));
		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.flush());
		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.finish());
	}
	else if (!strcmp(name,"dy")) {
		//if (OPS_xcl_core.constant[1] == NULL) {
		if (!const1_set){
			/*OPS_opencl_core.constant[1] = clCreateBuffer(OPS_opencl_core.context, CL_MEM_READ_WRITE, dim*typeSize, NULL, &ret);
			clSafeCall( ret );*/

			//OCL_CHECK(err, OPS_xcl_core.constant[1] = cl::Buffer(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, dim*typeSize, nullptr));
			OCL_CHECK(err, OPS_xcl_core.constant[1] = cl::Buffer(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, dim*typeSize, (void*) dat));
			const1_set = true;
		}
		//Write the new constant to the memory of the device
		/*clSafeCall( clEnqueueWriteBuffer(OPS_xcl_core.command_queue, OPS_xcl_core.constant[1], CL_TRUE, 0, dim*typeSize, (void*) dat, 0, NULL, NULL) );
			clSafeCall( clFlush(OPS_xcl_core.command_queue) );
			clSafeCall( clFinish(OPS_xcl_core.command_queue) );*/

		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.enqueueMigrateMemObjects({OPS_xcl_core.constant[1]},0/* 0 means from host*/));
		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.flush());
		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.finish());
	}
	else
	{

		//exit(1);

		//if (isbuilt_poisson_kernel_populate){
			printf("error: unknown const name\n");
			exit(1);
		//}
	}

}

//extern ops_opencl_core OPS_opencl_core;

void buildOpenCLKernels() {
	static bool isbuilt = false;

	if(!isbuilt) {
		//clSafeCall( clUnloadCompiler() );

		//OPS_xcl_core.n_kernels = 5;
		//OPS_opencl_core.kernel = (cl_kernel*) malloc(5*sizeof(cl_kernel));

		OPS_xcl_core.kernel.resize(5);
	}
	isbuilt = true;
}
/*
//user kernel files
//#include "poisson_kernel_error_opencl_kernel.cpp"
static bool isbuilt_poisson_kernel_error = false;

void buildOpenCLKernels_poisson_kernel_error(int xdim0, int xdim1) {

  //int ocl_fma = OCL_FMA;
  if(!isbuilt_poisson_kernel_error) {
    buildOpenCLKernels();
    //clSafeCall( clUnloadCompiler() );
    cl_int ret;
    char *fpga_bin;
         size_t fpga_bin_size;
         //fpga_bin_size = load_file_to_memory("/home/faraz/workspace/Poisson/Emulation-HW/ops_poission_kernels.xclbin", &fpga_bin);
         //fpga_bin_size = load_file_to_memory("../ops_poisson_kernel_error.xclbin", &fpga_bin);
         fpga_bin_size = load_file_to_memory("../ops_poisson_kernels.xclbin", &fpga_bin);
         printf("Error File: %d \n", fpga_bin_size);
         OPS_opencl_core.program = clCreateProgramWithBinary(OPS_opencl_core.context, 1, (const cl_device_id*) &OPS_opencl_core.device_id, &fpga_bin_size, (const unsigned char**) &fpga_bin, NULL, &ret);

      clSafeCall( ret );
      printf("Building errpr \n");


      // Build the program
      char buildOpts[255*3];
      char* pPath = NULL;
      pPath = getenv ("OPS_INSTALL_PATH");
      if (pPath!=NULL)
        if(OCL_FMA)
          sprintf(buildOpts,"-cl-mad-enable -DOCL_FMA -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_error=%d  -Dxdim1_poisson_kernel_error=%d ", pPath, 32,xdim0,xdim1);
        else
          sprintf(buildOpts,"-cl-mad-enable -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_error=%d  -Dxdim1_poisson_kernel_error=%d ", pPath, 32,xdim0,xdim1);
      else {
        sprintf((char*)"Incorrect OPS_INSTALL_PATH %s\n",pPath);
        exit(EXIT_FAILURE);
      }

      #ifdef OPS_SOA
      sprintf(buildOpts, "%s -DOPS_SOA", buildOpts);
      #endif

      ret = clBuildProgram(OPS_opencl_core.program, 1, &OPS_opencl_core.device_id, buildOpts, NULL, NULL);

      if(ret != CL_SUCCESS) {
    	  char* build_log;
        size_t log_size;
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size) );
        build_log = (char*) malloc(log_size+1);
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, log_size, build_log, NULL) );
        build_log[log_size] = '\0';
        fprintf(stderr, "=============== OpenCL Program Build Info ================\n\n%s", build_log);
        fprintf(stderr, "\n========================================================= \n");
        free(build_log);
        exit(EXIT_FAILURE);
      }
      printf("compiling poisson_kernel_error -- done\n");

    // Create the OpenCL kernel
    OPS_opencl_core.kernel[4] = clCreateKernel(OPS_opencl_core.program, "ops_poisson_kernel_error", &ret);
    clSafeCall( ret );

    isbuilt_poisson_kernel_error = true;
  }

}


// host stub function
void ops_par_loop_poisson_kernel_error(char const *name, ops_block block, int dim, int* range,
 ops_arg arg0, ops_arg arg1, ops_arg arg2) {

  //Timing
  double t1,t2,c1,c2;

  ops_arg args[3] = { arg0, arg1, arg2};


  #ifdef CHECKPOINTING
  if (!ops_checkpointing_before(args,3,range,4)) return;
  #endif

  if (OPS_diags > 1) {
    ops_timing_realloc(4,"poisson_kernel_error");
    OPS_kernels[4].count++;
    ops_timers_core(&c1,&t1);
  }

  //compute locally allocated range for the sub-block
  int start[2];
  int end[2];
  #ifdef OPS_MPI
  sub_block_list sb = OPS_sub_block_list[block->index];
  if (!sb->owned) return;
  for ( int n=0; n<2; n++ ){
    start[n] = sb->decomp_disp[n];end[n] = sb->decomp_disp[n]+sb->decomp_size[n];
    if (start[n] >= range[2*n]) {
      start[n] = 0;
    }
    else {
      start[n] = range[2*n] - start[n];
    }
    if (sb->id_m[n]==MPI_PROC_NULL && range[2*n] < 0) start[n] = range[2*n];
    if (end[n] >= range[2*n+1]) {
      end[n] = range[2*n+1] - sb->decomp_disp[n];
    }
    else {
      end[n] = sb->decomp_size[n];
    }
    if (sb->id_p[n]==MPI_PROC_NULL && (range[2*n+1] > sb->decomp_disp[n]+sb->decomp_size[n]))
      end[n] += (range[2*n+1]-sb->decomp_disp[n]-sb->decomp_size[n]);
  }
  #else
  for ( int n=0; n<2; n++ ){
    start[n] = range[2*n];end[n] = range[2*n+1];
  }
  #endif

  int x_size = MAX(0,end[0]-start[0]);
  int y_size = MAX(0,end[1]-start[1]);


  int xdim0 = args[0].dat->size[0];
  int xdim1 = args[1].dat->size[0];

  //build opencl kernel if not already built

  buildOpenCLKernels_poisson_kernel_error(
  xdim0,xdim1);

  //set up OpenCL thread blocks
  size_t globalWorkSize[3] = {((x_size-1)/OPS_block_size_x+ 1)*OPS_block_size_x, ((y_size-1)/OPS_block_size_y + 1)*OPS_block_size_y, 1};
  size_t localWorkSize[3] =  {OPS_block_size_x,OPS_block_size_y,OPS_block_size_z};


  #ifdef OPS_MPI
  double *arg2h = (double *)(((ops_reduction)args[2].data)->data + ((ops_reduction)args[2].data)->size * block->index);
  #else
  double *arg2h = (double *)(((ops_reduction)args[2].data)->data);
  #endif

  int nblocks = ((x_size-1)/OPS_block_size_x+ 1)*((y_size-1)/OPS_block_size_y + 1);
  int maxblocks = nblocks;
  int reduct_bytes = 0;

  reduct_bytes += ROUND_UP(maxblocks*1*sizeof(double));

  reallocReductArrays(reduct_bytes);
  reduct_bytes = 0;

  int r_bytes2 = reduct_bytes/sizeof(double);
  arg2.data = OPS_reduct_h + reduct_bytes;
  arg2.data_d = OPS_reduct_d;// + reduct_bytes;
  for (int b=0; b<maxblocks; b++)
  for (int d=0; d<1; d++) ((double *)arg2.data)[d+b*1] = ZERO_double;
  reduct_bytes += ROUND_UP(maxblocks*1*sizeof(double));


  mvReductArraysToDevice(reduct_bytes);

  //set up initial pointers
  int d_m[OPS_MAX_DIM];
  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d] + OPS_sub_dat_list[args[0].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d];
  #endif
  int base0 = 1 *1*
  (start[0] * args[0].stencil->stride[0] - args[0].dat->base[0] - d_m[0]);
  base0 = base0 + args[0].dat->size[0] *1*
  (start[1] * args[0].stencil->stride[1] - args[0].dat->base[1] - d_m[1]);

  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[1].dat->d_m[d] + OPS_sub_dat_list[args[1].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[1].dat->d_m[d];
  #endif
  int base1 = 1 *1*
  (start[0] * args[1].stencil->stride[0] - args[1].dat->base[0] - d_m[0]);
  base1 = base1 + args[1].dat->size[0] *1*
  (start[1] * args[1].stencil->stride[1] - args[1].dat->base[1] - d_m[1]);


  ops_H_D_exchanges_device(args, 3);
  ops_halo_exchanges(args,3,range);
  ops_H_D_exchanges_device(args, 3);

  if (OPS_diags > 1) {
    ops_timers_core(&c2,&t2);
    OPS_kernels[4].mpi_time += t2-t1;
  }

  int nthread = OPS_block_size_x*OPS_block_size_y*OPS_block_size_z;

  if (globalWorkSize[0]>0 && globalWorkSize[1]>0 && globalWorkSize[2]>0) {
	  clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 0, sizeof(cl_mem), (void*) &arg0.data_d ));
    //clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 0, sizeof(cl_mem), (void*) &arg0.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 1, sizeof(cl_mem), (void*) &arg1.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 2, sizeof(cl_mem), (void*) &arg2.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 3, nthread*sizeof(double), NULL));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 4, sizeof(cl_int), (void*) &r_bytes2 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 5, sizeof(cl_int), (void*) &base0 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 6, sizeof(cl_int), (void*) &base1 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 7, sizeof(cl_int), (void*) &x_size ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[4], 8, sizeof(cl_int), (void*) &y_size ));

    //call/enque opencl kernel wrapper function
    clSafeCall( clEnqueueNDRangeKernel(OPS_opencl_core.command_queue, OPS_opencl_core.kernel[4], 3, NULL, globalWorkSize, localWorkSize, 0, NULL, NULL) );
  }
  if (OPS_diags>1) {
    clSafeCall( clFinish(OPS_opencl_core.command_queue) );
  }

  if (OPS_diags > 1) {
    ops_timers_core(&c1,&t1);
    OPS_kernels[4].time += t1-t2;
  }

  mvReductArraysToHost(reduct_bytes);
  for ( int b=0; b<maxblocks; b++ ){
    for ( int d=0; d<1; d++ ){
      arg2h[d] = arg2h[d] + ((double *)arg2.data)[d+b*1];
    }
  }
  arg2.data = (char *)arg2h;

  ops_set_dirtybit_device(args, 3);

  if (OPS_diags > 1) {
    //Update kernel record
    ops_timers_core(&c2,&t2);
    OPS_kernels[4].mpi_time += t2-t1;
    OPS_kernels[4].transfer += ops_compute_transfer(dim, start, end, &arg0);
    OPS_kernels[4].transfer += ops_compute_transfer(dim, start, end, &arg1);
  }


}

//#include "poisson_kernel_stencil_opencl_kernel.cpp"
static bool isbuilt_poisson_kernel_stencil = false;
void buildOpenCLKernels_poisson_kernel_stencil(int xdim0, int xdim1) {

  //int ocl_fma = OCL_FMA;
  if(!isbuilt_poisson_kernel_stencil) {
    buildOpenCLKernels();
    //clSafeCall( clUnloadCompiler() );
    cl_int ret;
    char *fpga_bin;
         size_t fpga_bin_size;
         //fpga_bin_size = load_file_to_memory("/home/faraz/workspace/Poisson/Emulation-HW/ops_poission_kernels.xclbin", &fpga_bin);
         //fpga_bin_size = load_file_to_memory("../ops_poisson_kernel_stencil.xclbin", &fpga_bin);
         fpga_bin_size = load_file_to_memory("../ops_poisson_kernels.xclbin", &fpga_bin);
         printf("Stencil File: %d \n", fpga_bin_size);
         OPS_opencl_core.program = clCreateProgramWithBinary(OPS_opencl_core.context, 1, (const cl_device_id*) &OPS_opencl_core.device_id, &fpga_bin_size, (const unsigned char**) &fpga_bin, NULL, &ret);

      clSafeCall( ret );
      printf("Building stencil \n");


      // Build the program
      char buildOpts[255*2];
      char* pPath = NULL;
      pPath = getenv ("OPS_INSTALL_PATH");
      if (pPath!=NULL)
        if(OCL_FMA)
          sprintf(buildOpts,"-cl-mad-enable -DOCL_FMA -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_stencil=%d  -Dxdim1_poisson_kernel_stencil=%d ", pPath, 32,xdim0,xdim1);
        else
          sprintf(buildOpts,"-cl-mad-enable -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_stencil=%d  -Dxdim1_poisson_kernel_stencil=%d ", pPath, 32,xdim0,xdim1);
      else {
        sprintf((char*)"Incorrect OPS_INSTALL_PATH %s\n",pPath);
        exit(EXIT_FAILURE);
      }

      #ifdef OPS_SOA
      sprintf(buildOpts, "%s -DOPS_SOA", buildOpts);
      #endif

      ret = clBuildProgram(OPS_opencl_core.program, 1, &OPS_opencl_core.device_id, buildOpts, NULL, NULL);

      if(ret != CL_SUCCESS) {
        char* build_log;
        size_t log_size;
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size) );
        build_log = (char*) malloc(log_size+1);
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, log_size, build_log, NULL) );
        build_log[log_size] = '\0';
        fprintf(stderr, "=============== OpenCL Program Build Info ================\n\n%s", build_log);
        fprintf(stderr, "\n========================================================= \n");
        free(build_log);
        exit(EXIT_FAILURE);
      }
      printf("compiling poisson_kernel_stencil -- done\n");

    // Create the OpenCL kernel
    OPS_opencl_core.kernel[3] = clCreateKernel(OPS_opencl_core.program, "ops_poisson_kernel_stencil", &ret);
    clSafeCall( ret );

    isbuilt_poisson_kernel_stencil = true;
  }

}


// host stub function
void ops_par_loop_poisson_kernel_stencil(char const *name, ops_block block, int dim, int* range,
 ops_arg arg0, ops_arg arg1) {

  //Timing
  double t1,t2,c1,c2;

  ops_arg args[2] = { arg0, arg1};


  #ifdef CHECKPOINTING
  if (!ops_checkpointing_before(args,2,range,3)) return;
  #endif

  if (OPS_diags > 1) {
    ops_timing_realloc(3,"poisson_kernel_stencil");
    OPS_kernels[3].count++;
    ops_timers_core(&c1,&t1);
  }

  //compute locally allocated range for the sub-block
  int start[2];
  int end[2];
  #ifdef OPS_MPI
  sub_block_list sb = OPS_sub_block_list[block->index];
  if (!sb->owned) return;
  for ( int n=0; n<2; n++ ){
    start[n] = sb->decomp_disp[n];end[n] = sb->decomp_disp[n]+sb->decomp_size[n];
    if (start[n] >= range[2*n]) {
      start[n] = 0;
    }
    else {
      start[n] = range[2*n] - start[n];
    }
    if (sb->id_m[n]==MPI_PROC_NULL && range[2*n] < 0) start[n] = range[2*n];
    if (end[n] >= range[2*n+1]) {
      end[n] = range[2*n+1] - sb->decomp_disp[n];
    }
    else {
      end[n] = sb->decomp_size[n];
    }
    if (sb->id_p[n]==MPI_PROC_NULL && (range[2*n+1] > sb->decomp_disp[n]+sb->decomp_size[n]))
      end[n] += (range[2*n+1]-sb->decomp_disp[n]-sb->decomp_size[n]);
  }
  #else
  for ( int n=0; n<2; n++ ){
    start[n] = range[2*n];end[n] = range[2*n+1];
  }
  #endif

  int x_size = MAX(0,end[0]-start[0]);
  int y_size = MAX(0,end[1]-start[1]);


  int xdim0 = args[0].dat->size[0];
  int xdim1 = args[1].dat->size[0];

  //build opencl kernel if not already built

  buildOpenCLKernels_poisson_kernel_stencil(
  xdim0,xdim1);

  //set up OpenCL thread blocks
  size_t globalWorkSize[3] = {((x_size-1)/OPS_block_size_x+ 1)*OPS_block_size_x, ((y_size-1)/OPS_block_size_y + 1)*OPS_block_size_y, 1};
  size_t localWorkSize[3] =  {OPS_block_size_x,OPS_block_size_y,OPS_block_size_z};






  //set up initial pointers
  int d_m[OPS_MAX_DIM];
  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d] + OPS_sub_dat_list[args[0].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d];
  #endif
  int base0 = 1 *1*
  (start[0] * args[0].stencil->stride[0] - args[0].dat->base[0] - d_m[0]);
  base0 = base0 + args[0].dat->size[0] *1*
  (start[1] * args[0].stencil->stride[1] - args[0].dat->base[1] - d_m[1]);

  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[1].dat->d_m[d] + OPS_sub_dat_list[args[1].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[1].dat->d_m[d];
  #endif
  int base1 = 1 *1*
  (start[0] * args[1].stencil->stride[0] - args[1].dat->base[0] - d_m[0]);
  base1 = base1 + args[1].dat->size[0] *1*
  (start[1] * args[1].stencil->stride[1] - args[1].dat->base[1] - d_m[1]);


  ops_H_D_exchanges_device(args, 2);
  ops_halo_exchanges(args,2,range);
  ops_H_D_exchanges_device(args, 2);

  if (OPS_diags > 1) {
    ops_timers_core(&c2,&t2);
    OPS_kernels[3].mpi_time += t2-t1;
  }

  if (globalWorkSize[0]>0 && globalWorkSize[1]>0 && globalWorkSize[2]>0) {

    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[3], 0, sizeof(cl_mem), (void*) &arg0.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[3], 1, sizeof(cl_mem), (void*) &arg1.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[3], 2, sizeof(cl_int), (void*) &base0 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[3], 3, sizeof(cl_int), (void*) &base1 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[3], 4, sizeof(cl_int), (void*) &x_size ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[3], 5, sizeof(cl_int), (void*) &y_size ));

    //call/enque opencl kernel wrapper function
    clSafeCall( clEnqueueNDRangeKernel(OPS_opencl_core.command_queue, OPS_opencl_core.kernel[3], 3, NULL, globalWorkSize, localWorkSize, 0, NULL, NULL) );
  }
  if (OPS_diags>1) {
    clSafeCall( clFinish(OPS_opencl_core.command_queue) );
  }

  if (OPS_diags > 1) {
    ops_timers_core(&c1,&t1);
    OPS_kernels[3].time += t1-t2;
  }

  ops_set_dirtybit_device(args, 2);
  ops_set_halo_dirtybit3(&args[1],range);

  if (OPS_diags > 1) {
    //Update kernel record
    ops_timers_core(&c2,&t2);
    OPS_kernels[3].mpi_time += t2-t1;
    OPS_kernels[3].transfer += ops_compute_transfer(dim, start, end, &arg0);
    OPS_kernels[3].transfer += ops_compute_transfer(dim, start, end, &arg1);
  }
}


//#include "poisson_kernel_initial_opencl_kernel.cpp"
static bool isbuilt_poisson_kernel_initial = false;

void buildOpenCLKernels_poisson_kernel_initial(int xdim0) {

  //int ocl_fma = OCL_FMA;
  if(!isbuilt_poisson_kernel_initial) {
    buildOpenCLKernels();
    //clSafeCall( clUnloadCompiler() );
    cl_int ret;
    char *fpga_bin;
         size_t fpga_bin_size;
         //fpga_bin_size = load_file_to_memory("/home/faraz/workspace/Poisson/Emulation-HW/ops_poission_kernels.xclbin", &fpga_bin);
         //fpga_bin_size = load_file_to_memory("../ops_poisson_kernel_initial.xclbin", &fpga_bin);
         fpga_bin_size = load_file_to_memory("../ops_poisson_kernels.xclbin", &fpga_bin);
         printf("Initial File: %d \n", fpga_bin_size);
         OPS_opencl_core.program = clCreateProgramWithBinary(OPS_opencl_core.context, 1, (const cl_device_id*) &OPS_opencl_core.device_id, &fpga_bin_size, (const unsigned char**) &fpga_bin, NULL, &ret);

      clSafeCall( ret );
      printf("Building initial \n");


      // Build the program
      char buildOpts[255*1];
      char* pPath = NULL;
      pPath = getenv ("OPS_INSTALL_PATH");
      if (pPath!=NULL)
        if(OCL_FMA)
          sprintf(buildOpts,"-cl-mad-enable -DOCL_FMA -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_initial=%d ", pPath, 32,xdim0);
        else
          sprintf(buildOpts,"-cl-mad-enable -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_initial=%d ", pPath, 32,xdim0);
      else {
        sprintf((char*)"Incorrect OPS_INSTALL_PATH %s\n",pPath);
        exit(EXIT_FAILURE);
      }

      #ifdef OPS_SOA
      sprintf(buildOpts, "%s -DOPS_SOA", buildOpts);
      #endif

      ret = clBuildProgram(OPS_opencl_core.program, 1, &OPS_opencl_core.device_id, buildOpts, NULL, NULL);

      if(ret != CL_SUCCESS) {
        char* build_log;
        size_t log_size;
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size) );
        build_log = (char*) malloc(log_size+1);
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, log_size, build_log, NULL) );
        build_log[log_size] = '\0';
        fprintf(stderr, "=============== OpenCL Program Build Info ================\n\n%s", build_log);
        fprintf(stderr, "\n========================================================= \n");
        free(build_log);
        exit(EXIT_FAILURE);
      }
      printf("compiling poisson_kernel_initial -- done\n");

    // Create the OpenCL kernel
    OPS_opencl_core.kernel[2] = clCreateKernel(OPS_opencl_core.program, "ops_poisson_kernel_initial", &ret);
    clSafeCall( ret );

    isbuilt_poisson_kernel_initial = true;
  }

}


// host stub function
void ops_par_loop_poisson_kernel_initial(char const *name, ops_block block, int dim, int* range,
 ops_arg arg0) {

  //Timing
  double t1,t2,c1,c2;

  ops_arg args[1] = { arg0};


  #ifdef CHECKPOINTING
  if (!ops_checkpointing_before(args,1,range,2)) return;
  #endif

  if (OPS_diags > 1) {
    ops_timing_realloc(2,"poisson_kernel_initial");
    OPS_kernels[2].count++;
    ops_timers_core(&c1,&t1);
  }

  //compute locally allocated range for the sub-block
  int start[2];
  int end[2];
  #ifdef OPS_MPI
  sub_block_list sb = OPS_sub_block_list[block->index];
  if (!sb->owned) return;
  for ( int n=0; n<2; n++ ){
    start[n] = sb->decomp_disp[n];end[n] = sb->decomp_disp[n]+sb->decomp_size[n];
    if (start[n] >= range[2*n]) {
      start[n] = 0;
    }
    else {
      start[n] = range[2*n] - start[n];
    }
    if (sb->id_m[n]==MPI_PROC_NULL && range[2*n] < 0) start[n] = range[2*n];
    if (end[n] >= range[2*n+1]) {
      end[n] = range[2*n+1] - sb->decomp_disp[n];
    }
    else {
      end[n] = sb->decomp_size[n];
    }
    if (sb->id_p[n]==MPI_PROC_NULL && (range[2*n+1] > sb->decomp_disp[n]+sb->decomp_size[n]))
      end[n] += (range[2*n+1]-sb->decomp_disp[n]-sb->decomp_size[n]);
  }
  #else
  for ( int n=0; n<2; n++ ){
    start[n] = range[2*n];end[n] = range[2*n+1];
  }
  #endif

  int x_size = MAX(0,end[0]-start[0]);
  int y_size = MAX(0,end[1]-start[1]);


  int xdim0 = args[0].dat->size[0];

  //build opencl kernel if not already built

  buildOpenCLKernels_poisson_kernel_initial(
  xdim0);

  //set up OpenCL thread blocks
  size_t globalWorkSize[3] = {((x_size-1)/OPS_block_size_x+ 1)*OPS_block_size_x, ((y_size-1)/OPS_block_size_y + 1)*OPS_block_size_y, 1};
  size_t localWorkSize[3] =  {OPS_block_size_x,OPS_block_size_y,OPS_block_size_z};






  //set up initial pointers
  int d_m[OPS_MAX_DIM];
  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d] + OPS_sub_dat_list[args[0].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d];
  #endif
  int base0 = 1 *1*
  (start[0] * args[0].stencil->stride[0] - args[0].dat->base[0] - d_m[0]);
  base0 = base0 + args[0].dat->size[0] *1*
  (start[1] * args[0].stencil->stride[1] - args[0].dat->base[1] - d_m[1]);


  ops_H_D_exchanges_device(args, 1);
  ops_halo_exchanges(args,1,range);
  ops_H_D_exchanges_device(args, 1);

  if (OPS_diags > 1) {
    ops_timers_core(&c2,&t2);
    OPS_kernels[2].mpi_time += t2-t1;
  }

  if (globalWorkSize[0]>0 && globalWorkSize[1]>0 && globalWorkSize[2]>0) {

    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[2], 0, sizeof(cl_mem), (void*) &arg0.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[2], 1, sizeof(cl_int), (void*) &base0 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[2], 2, sizeof(cl_int), (void*) &x_size ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[2], 3, sizeof(cl_int), (void*) &y_size ));

    //call/enque opencl kernel wrapper function
    clSafeCall( clEnqueueNDRangeKernel(OPS_opencl_core.command_queue, OPS_opencl_core.kernel[2], 3, NULL, globalWorkSize, localWorkSize, 0, NULL, NULL) );
  }
  if (OPS_diags>1) {
    clSafeCall( clFinish(OPS_opencl_core.command_queue) );
  }

  if (OPS_diags > 1) {
    ops_timers_core(&c1,&t1);
    OPS_kernels[2].time += t1-t2;
  }

  ops_set_dirtybit_device(args, 1);
  ops_set_halo_dirtybit3(&args[0],range);

  if (OPS_diags > 1) {
    //Update kernel record
    ops_timers_core(&c2,&t2);
    OPS_kernels[2].mpi_time += t2-t1;
    OPS_kernels[2].transfer += ops_compute_transfer(dim, start, end, &arg0);
  }
}


//#include "poisson_kernel_update_opencl_kernel.cpp"
static bool isbuilt_poisson_kernel_update = false;

void buildOpenCLKernels_poisson_kernel_update(int xdim0, int xdim1) {
    printf("Building update kernels \n");

  //int ocl_fma = OCL_FMA;
  if(!isbuilt_poisson_kernel_update) {
    buildOpenCLKernels();
    //clSafeCall( clUnloadCompiler() );
    cl_int ret;
    char *fpga_bin;
            size_t fpga_bin_size;
            //fpga_bin_size = load_file_to_memory("/home/faraz/workspace/Poisson/Emulation-HW/ops_poission_kernels.xclbin", &fpga_bin);
            //fpga_bin_size = load_file_to_memory("../ops_poisson_kernel_update.xclbin", &fpga_bin);
            fpga_bin_size = load_file_to_memory("../ops_poisson_kernels.xclbin", &fpga_bin);


          printf("Update Kernel Size: %d \n", fpga_bin_size);
            OPS_opencl_core.program = clCreateProgramWithBinary(OPS_opencl_core.context, 1, (const cl_device_id*) &OPS_opencl_core.device_id, &fpga_bin_size, (const unsigned char**) &fpga_bin, NULL, &ret);

         clSafeCall( ret );


      // Build the program
      char buildOpts[255*2];
      char* pPath = NULL;
      printf("\n test \n");

      pPath = getenv ("OPS_INSTALL_PATH");
      if (pPath!=NULL)
        if(OCL_FMA)
          sprintf(buildOpts,"-cl-mad-enable -DOCL_FMA -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_update=%d  -Dxdim1_poisson_kernel_update=%d ", pPath, 32,xdim0,xdim1);
        else
          sprintf(buildOpts,"-cl-mad-enable -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim0_poisson_kernel_update=%d  -Dxdim1_poisson_kernel_update=%d ", pPath, 32,xdim0,xdim1);
      else {
        sprintf((char*)"Incorrect OPS_INSTALL_PATH %s\n",pPath);
        exit(EXIT_FAILURE);
      }

      #ifdef OPS_SOA
      sprintf(buildOpts, "%s -DOPS_SOA", buildOpts);
      #endif

      ret = clBuildProgram(OPS_opencl_core.program, 1, &OPS_opencl_core.device_id, buildOpts, NULL, NULL);

      if(ret != CL_SUCCESS) {
        char* build_log;
        size_t log_size;
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size) );
        build_log = (char*) malloc(log_size+1);
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, log_size, build_log, NULL) );
        build_log[log_size] = '\0';
        fprintf(stderr, "=============== OpenCL Program Build Info ================\n\n%s", build_log);
        fprintf(stderr, "\n========================================================= \n");
        free(build_log);
        exit(EXIT_FAILURE);
      }
      printf("compiling poisson_kernel_update -- done\n");

    // Create the OpenCL kernel
    OPS_opencl_core.kernel[1] = clCreateKernel(OPS_opencl_core.program, "ops_poisson_kernel_update", &ret);
    clSafeCall( ret );

    isbuilt_poisson_kernel_update = true;
  }

}


// host stub function
void ops_par_loop_poisson_kernel_update(char const *name, ops_block block, int dim, int* range,
 ops_arg arg0, ops_arg arg1) {

  //Timing
  double t1,t2,c1,c2;

  ops_arg args[2] = { arg0, arg1};


  #ifdef CHECKPOINTING
  if (!ops_checkpointing_before(args,2,range,1)) return;
  #endif

  if (OPS_diags > 1) {
    ops_timing_realloc(1,"poisson_kernel_update");
    OPS_kernels[1].count++;
    ops_timers_core(&c1,&t1);
  }

  //compute locally allocated range for the sub-block
  int start[2];
  int end[2];
  #ifdef OPS_MPI
  sub_block_list sb = OPS_sub_block_list[block->index];
  if (!sb->owned) return;
  for ( int n=0; n<2; n++ ){
    start[n] = sb->decomp_disp[n];end[n] = sb->decomp_disp[n]+sb->decomp_size[n];
    if (start[n] >= range[2*n]) {
      start[n] = 0;
    }
    else {
      start[n] = range[2*n] - start[n];
    }
    if (sb->id_m[n]==MPI_PROC_NULL && range[2*n] < 0) start[n] = range[2*n];
    if (end[n] >= range[2*n+1]) {
      end[n] = range[2*n+1] - sb->decomp_disp[n];
    }
    else {
      end[n] = sb->decomp_size[n];
    }
    if (sb->id_p[n]==MPI_PROC_NULL && (range[2*n+1] > sb->decomp_disp[n]+sb->decomp_size[n]))
      end[n] += (range[2*n+1]-sb->decomp_disp[n]-sb->decomp_size[n]);
  }
  #else
  for ( int n=0; n<2; n++ ){
    start[n] = range[2*n];end[n] = range[2*n+1];
  }
  #endif

  int x_size = MAX(0,end[0]-start[0]);
  int y_size = MAX(0,end[1]-start[1]);


  int xdim0 = args[0].dat->size[0];
  int xdim1 = args[1].dat->size[0];

  //build opencl kernel if not already built

  buildOpenCLKernels_poisson_kernel_update(
  xdim0,xdim1);

  //set up OpenCL thread blocks
  size_t globalWorkSize[3] = {((x_size-1)/OPS_block_size_x+ 1)*OPS_block_size_x, ((y_size-1)/OPS_block_size_y + 1)*OPS_block_size_y, 1};
  size_t localWorkSize[3] =  {OPS_block_size_x,OPS_block_size_y,OPS_block_size_z};






  //set up initial pointers
  int d_m[OPS_MAX_DIM];
  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d] + OPS_sub_dat_list[args[0].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[0].dat->d_m[d];
  #endif
  int base0 = 1 *1*
  (start[0] * args[0].stencil->stride[0] - args[0].dat->base[0] - d_m[0]);
  base0 = base0 + args[0].dat->size[0] *1*
  (start[1] * args[0].stencil->stride[1] - args[0].dat->base[1] - d_m[1]);

  #ifdef OPS_MPI
  for (int d = 0; d < dim; d++) d_m[d] = args[1].dat->d_m[d] + OPS_sub_dat_list[args[1].dat->index]->d_im[d];
  #else
  for (int d = 0; d < dim; d++) d_m[d] = args[1].dat->d_m[d];
  #endif
  int base1 = 1 *1*
  (start[0] * args[1].stencil->stride[0] - args[1].dat->base[0] - d_m[0]);
  base1 = base1 + args[1].dat->size[0] *1*
  (start[1] * args[1].stencil->stride[1] - args[1].dat->base[1] - d_m[1]);


  ops_H_D_exchanges_device(args, 2);
  ops_halo_exchanges(args,2,range);
  ops_H_D_exchanges_device(args, 2);

  if (OPS_diags > 1) {
    ops_timers_core(&c2,&t2);
    OPS_kernels[1].mpi_time += t2-t1;
  }

  if (globalWorkSize[0]>0 && globalWorkSize[1]>0 && globalWorkSize[2]>0) {

    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[1], 0, sizeof(cl_mem), (void*) &arg0.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[1], 1, sizeof(cl_mem), (void*) &arg1.data_d ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[1], 2, sizeof(cl_int), (void*) &base0 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[1], 3, sizeof(cl_int), (void*) &base1 ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[1], 4, sizeof(cl_int), (void*) &x_size ));
    clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[1], 5, sizeof(cl_int), (void*) &y_size ));

    //call/enque opencl kernel wrapper function
    clSafeCall( clEnqueueNDRangeKernel(OPS_opencl_core.command_queue, OPS_opencl_core.kernel[1], 3, NULL, globalWorkSize, localWorkSize, 0, NULL, NULL) );
  }
  if (OPS_diags>1) {
    clSafeCall( clFinish(OPS_opencl_core.command_queue) );
  }

  if (OPS_diags > 1) {
    ops_timers_core(&c1,&t1);
    OPS_kernels[1].time += t1-t2;
  }

  ops_set_dirtybit_device(args, 2);
  ops_set_halo_dirtybit3(&args[1],range);

  if (OPS_diags > 1) {
    //Update kernel record
    ops_timers_core(&c2,&t2);
    OPS_kernels[1].mpi_time += t2-t1;
    OPS_kernels[1].transfer += ops_compute_transfer(dim, start, end, &arg0);
    OPS_kernels[1].transfer += ops_compute_transfer(dim, start, end, &arg1);
  }
}
 */

//#include "poisson_kernel_populate_opencl_kernel.cpp"
//Moved to top
//static bool isbuilt_poisson_kernel_populate = false;

void buildOpenCLKernels_poisson_kernel_populate(int xdim3, int xdim4, int xdim5) {

	//int ocl_fma = OCL_FMA;
	if(!isbuilt_poisson_kernel_populate) {
		buildOpenCLKernels();
		//clSafeCall( clUnloadCompiler() );


		//cl_int ret;

		/*char *fpga_bin;
     	 size_t fpga_bin_size;
		 fpga_bin_size = load_file_to_memory("../ops_poisson_kernels.xclbin", &fpga_bin);
		 printf("Populate Kernel Size: %d \n", fpga_bin_size);
		 OPS_opencl_core.program = clCreateProgramWithBinary(OPS_opencl_core.context, 1, (const cl_device_id*) &OPS_opencl_core.device_id, &fpga_bin_size, (const unsigned char**) &fpga_bin, NULL, &ret);
		 */

		//OPS_opencl_core.program
		//static const int DATA_SIZE = 1024;
		//size_t size_in_bytes = DATA_SIZE * sizeof(int);
		cl_int err;
		unsigned fileBufSize;

		// The get_xil_devices will return vector of Xilinx Devices
		std::vector<cl::Device> devices = xcl::get_xil_devices();
		cl::Device device = devices[0];

		//Creating Context and Command Queue for selected Device
		OCL_CHECK(err, OPS_xcl_core.context = cl::Context(device, NULL, NULL, NULL, &err));
		OCL_CHECK(err, OPS_xcl_core.command_queue =  cl::CommandQueue(OPS_xcl_core.context, device, CL_QUEUE_PROFILING_ENABLE, &err));
		OCL_CHECK(err, std::string device_name = device.getInfo<CL_DEVICE_NAME>(&err));
		ops_printf("Found Device %s \n", device_name.c_str());

		char* fileBuf = xcl::read_binary_file("../ops_poisson_kernels.xclbin", fileBufSize);
		cl::Program::Binaries bins{{fileBuf, fileBufSize}};
		devices.resize(1);
		OCL_CHECK(err, OPS_xcl_core.program = cl::Program(OPS_xcl_core.context, devices, bins, NULL, &err));
		OCL_CHECK(err, OPS_xcl_core.kernel[0] = cl::Kernel(OPS_xcl_core.program, "ops_poisson_kernel_populate", &err));

		//clSafeCall( ret );

		// Build the program
		//char buildOpts[255*6];
		//char* pPath = NULL;
		//pPath = getenv ("OPS_INSTALL_PATH");
		//pPath = "/home/faraz/workspace/Poisson/ops/c/include";

		/*if (pPath!=NULL)
        if(OCL_FMA)
          sprintf(buildOpts,"-cl-mad-enable -DOCL_FMA -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim3_poisson_kernel_populate=%d  -Dxdim4_poisson_kernel_populate=%d  -Dxdim5_poisson_kernel_populate=%d ", pPath, 32,xdim3,xdim4,xdim5);
        else
          sprintf(buildOpts,"-cl-mad-enable -I%s/c/include -DOPS_WARPSIZE=%d  -Dxdim3_poisson_kernel_populate=%d  -Dxdim4_poisson_kernel_populate=%d  -Dxdim5_poisson_kernel_populate=%d ", pPath, 32,xdim3,xdim4,xdim5);
      else {
        sprintf((char*)"Incorrect OPS_INSTALL_PATH %s\n",pPath);
        exit(EXIT_FAILURE);
      }*/

		/*#ifdef OPS_SOA
      sprintf(buildOpts, "%s -DOPS_SOA", buildOpts);
      #endif
      printf("Build options: %s \n", buildOpts);*/


		/*ret = clBuildProgram(OPS_opencl_core.program, 1, &OPS_opencl_core.device_id, buildOpts, NULL, NULL);
      //ret = clBuildProgram(OPS_opencl_core.program, 1, &OPS_opencl_core.device_id, NULL, NULL, NULL);

      if(ret != CL_SUCCESS) {
        char* build_log;
        size_t log_size;
        clSafeCall(u clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size) );
        build_log = (char*) malloc(log_size+1);
        clSafeCall( clGetProgramBuildInfo(OPS_opencl_core.program, OPS_opencl_core.device_id, CL_PROGRAM_BUILD_LOG, log_size, build_log, NULL) );
        build_log[log_size] = '\0';
        fprintf(stderr, "=============== OpenCL Program Build Info ================\n\n%s", build_log);
        fprintf(stderr, "\n========================================================= \n");
        free(build_log);
        exit(EXIT_FAILURE);
      }
      printf("compiling poisson_kernel_populate\n");*/

		// Create the OpenCL kernel
		//OPS_opencl_core.kernel[0] = clCreateKernel(OPS_opencl_core.program, "ops_poisson_kernel_populate", &ret);
		//clSafeCall( ret );

		isbuilt_poisson_kernel_populate = true;
	}

}


// host stub function
void ops_par_loop_poisson_kernel_populate(char const *name, ops_block block, int dim, int* range,
		ops_arg arg0, ops_arg arg1, ops_arg arg2, ops_arg arg3,
		ops_arg arg4, ops_arg arg5) {

	//Timing
	double t1,t2,c1,c2;

	ops_arg args[6] = { arg0, arg1, arg2, arg3, arg4, arg5};


#ifdef CHECKPOINTING
	if (!ops_checkpointing_before(args,6,range,0)) return;
#endif

	if (OPS_diags > 1) {
		ops_timing_realloc(0,"poisson_kernel_populate");
		printf("count++");
		OPS_kernels[0].count++;
		ops_timers_core(&c1,&t1);
	}

	//compute locally allocated range for the sub-block
	int start[2];
	int end[2];
#ifdef OPS_MPI
	sub_block_list sb = OPS_sub_block_list[block->index];
	if (!sb->owned) return;
	for ( int n=0; n<2; n++ ){
		start[n] = sb->decomp_disp[n];end[n] = sb->decomp_disp[n]+sb->decomp_size[n];
		if (start[n] >= range[2*n]) {
			start[n] = 0;
		}
		else {
			start[n] = range[2*n] - start[n];
		}
		if (sb->id_m[n]==MPI_PROC_NULL && range[2*n] < 0) start[n] = range[2*n];
		if (end[n] >= range[2*n+1]) {
			end[n] = range[2*n+1] - sb->decomp_disp[n];
		}
		else {
			end[n] = sb->decomp_size[n];
		}
		if (sb->id_p[n]==MPI_PROC_NULL && (range[2*n+1] > sb->decomp_disp[n]+sb->decomp_size[n]))
			end[n] += (range[2*n+1]-sb->decomp_disp[n]-sb->decomp_size[n]);
	}
#else
	for ( int n=0; n<2; n++ ){
		start[n] = range[2*n];end[n] = range[2*n+1];
	}
#endif

	int x_size = MAX(0,end[0]-start[0]);
	int y_size = MAX(0,end[1]-start[1]);

	int arg_idx[2];
#ifdef OPS_MPI
	arg_idx[0] = sb->decomp_disp[0]+start[0];
	arg_idx[1] = sb->decomp_disp[1]+start[1];
#else
	arg_idx[0] = start[0];
	arg_idx[1] = start[1];
#endif

	int xdim3 = args[3].dat->size[0];
	int xdim4 = args[4].dat->size[0];
	int xdim5 = args[5].dat->size[0];

	printf("dims: %d, %d, %d\n", xdim3, xdim4, xdim5);
	//build opencl kernel if not already built

	buildOpenCLKernels_poisson_kernel_populate(
			xdim3,xdim4,xdim5);


	//set up OpenCL thread blocks
	size_t globalWorkSize[3] = {((x_size-1)/OPS_block_size_x+ 1)*OPS_block_size_x, ((y_size-1)/OPS_block_size_y + 1)*OPS_block_size_y, 1};
	size_t localWorkSize[3] =  {OPS_block_size_x,OPS_block_size_y,OPS_block_size_z};






	//set up initial pointers
	int d_m[OPS_MAX_DIM];
#ifdef OPS_MPI
	for (int d = 0; d < dim; d++) d_m[d] = args[3].dat->d_m[d] + OPS_sub_dat_list[args[3].dat->index]->d_im[d];
#else
	for (int d = 0; d < dim; d++) d_m[d] = args[3].dat->d_m[d];
#endif
	int base3 = 1 *1*
			(start[0] * args[3].stencil->stride[0] - args[3].dat->base[0] - d_m[0]);
	base3 = base3 + args[3].dat->size[0] *1*
			(start[1] * args[3].stencil->stride[1] - args[3].dat->base[1] - d_m[1]);

#ifdef OPS_MPI
	for (int d = 0; d < dim; d++) d_m[d] = args[4].dat->d_m[d] + OPS_sub_dat_list[args[4].dat->index]->d_im[d];
#else
	for (int d = 0; d < dim; d++) d_m[d] = args[4].dat->d_m[d];
#endif
	int base4 = 1 *1*
			(start[0] * args[4].stencil->stride[0] - args[4].dat->base[0] - d_m[0]);
	base4 = base4 + args[4].dat->size[0] *1*
			(start[1] * args[4].stencil->stride[1] - args[4].dat->base[1] - d_m[1]);

#ifdef OPS_MPI
	for (int d = 0; d < dim; d++) d_m[d] = args[5].dat->d_m[d] + OPS_sub_dat_list[args[5].dat->index]->d_im[d];
#else
	for (int d = 0; d < dim; d++) d_m[d] = args[5].dat->d_m[d];
#endif
	int base5 = 1 *1*
			(start[0] * args[5].stencil->stride[0] - args[5].dat->base[0] - d_m[0]);
	base5 = base5 + args[5].dat->size[0] *1*
			(start[1] * args[5].stencil->stride[1] - args[5].dat->base[1] - d_m[1]);


	ops_H_D_exchanges_device(args, 6);
	ops_halo_exchanges(args,6,range);
	ops_H_D_exchanges_device(args, 6);

	if (OPS_diags > 1) {
		ops_timers_core(&c2,&t2);
		OPS_kernels[0].mpi_time += t2-t1;
	}

	cl_int err = 0;
	//ops_decl_const2( "dx",1, "double",&dx);
	//ops_decl_const2( "dy",1, "double",&dy);

	//OCL_CHECK(err, cl::Buffer faraz0(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, 8, (void*) &dx, &err));
	//OCL_CHECK(err, cl::Buffer faraz1(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, 8, (void*) &dy, &err));

	//OCL_CHECK(err, cl::Buffer test(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, 4, (void*) &arg0.data, &err));

	int narg = 0;

	if (globalWorkSize[0]>0 && globalWorkSize[1]>0 && globalWorkSize[2]>0) {

		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 0, sizeof(cl_int), (void*) arg0.data ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 1, sizeof(cl_int), (void*) arg1.data ));



		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) arg0.data ));
		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, test ));


		ops_printf("narg: %d \n", narg);
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) arg1.data ));
		ops_printf("narg: %d \n", narg);

		//Original
		//clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[0], 2, sizeof(arg3.data_d), (void*) arg3.data_d ));
		//clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[0], 3, sizeof(arg3.data_d), (void*) arg3.data_d ));
		//clSafeCall( clSetKernelArg(OPS_opencl_core.kernel[0], 4, sizeof(arg4.data_d), (void*) arg4.data_d ));

		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_double)*(22*22*22), (void*) &arg3.data_d ));

		/*cl_mem_ext_ptr_t d_bank0_ext;
		d_bank0_ext.flags = 1 | XCL_MEM_TOPOLOGY;
		d_bank0_ext.obj = NULL;
		d_bank0_ext.param = 0;*/

		//OCL_CHECK(err,  cl::Buffer test(OPS_xcl_core.context, CL_MEM_READ_WRITE, dim*typeSize, nullptr));
		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_mem), (void*) &arg3.data_d ));
		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_mem), (void*) &arg3.data_d ));


		//OCL_CHECK(err, cl::Buffer buff2(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(cl_mem), (void*) &arg3.data_d, &err));
		OCL_CHECK(err, cl::Buffer buff2(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(cl_mem), (void*) &arg3.data_d, &err));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, buff2 ));

		ops_printf("narg: %d \n", narg);

		OCL_CHECK(err, cl::Buffer buff3(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(cl_mem), (void*) &arg4.data_d, &err));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, buff3 ));

		ops_printf("narg: %d \n", narg);

		OCL_CHECK(err, cl::Buffer buff4(OPS_xcl_core.context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(cl_mem), (void*) &arg5.data_d, &err));
				OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, buff4 ));

		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.enqueueMigrateMemObjects({buff2, buff3, buff4}, 0));
		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, 8, (void*) &arg3.data_d ));
		ops_printf("narg: %d \n", narg);
		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_mem), (void*) &arg4.data_d ));
		//OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_mem), (void*) &arg5.data_d ));


		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 5, sizeof(cl_double), (void*) &dx ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 6, sizeof(cl_double), (void*) &dy ));

		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_double), (void*) &dx ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_double), (void*) &dy ));


		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 7, sizeof(cl_int), (void*) &base3 ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 8, sizeof(cl_int), (void*) &base4 ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 9, sizeof(cl_int), (void*) &base5 ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 10, sizeof(cl_int), (void*) &arg_idx[0] ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 11, sizeof(cl_int), (void*) &arg_idx[1] ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 12, sizeof(cl_int), (void*) &x_size ));
		//clSafeCall( clSetKernelArg(OPS_xcl_core.kernel[0], 13, sizeof(cl_int), (void*) &y_size ));

		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &base3 ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &base4 ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &base5 ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &arg_idx[0] ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &arg_idx[1] ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &x_size ));
		OCL_CHECK(err, err = OPS_xcl_core.kernel[0].setArg(narg++, sizeof(cl_int), (void*) &y_size ));




		printf("End of set kernel args\n");
		//exit(0);
		//call/enque opencl kernel wrapper function
		//clSafeCall( clEnqueueNDRangeKernel(OPS_xcl_core.command_queue, OPS_xcl_core.kernel[0], 3, NULL, globalWorkSize, localWorkSize, 0, NULL, NULL) );

		//#TODO: Dimmensions?

		//ops_printf("BOSS1: arg3:%f, arg4:%f, arg5:%f, arg0:%d, arg1:%d, base3:%d, base4:%d, base5:%d, arg_idx0:%d, arg_idx1:%d, size0:%d, size1:%d, dx:%f, dy:%f \n", atof(arg3.data_d), atof(arg4.data_d), atof(arg5.data_d), atoi(arg0.data), atoi(arg1.data), base3, base4, base5, arg_idx[0], arg_idx[1], x_size, y_size, dx, dy);
		OCL_CHECK(err, err = OPS_xcl_core.command_queue.enqueueNDRangeKernel(OPS_xcl_core.kernel[0], 0, *globalWorkSize, *localWorkSize, NULL, NULL));
		//ops_printf("BOSS2: arg3:%f, arg4:%f, arg5:%f, arg0:%d, arg1:%d, base3:%d, base4:%d, base5:%d, arg_idx0:%d, arg_idx1:%d, size0:%d, size1:%d, dx:%f, dy:%f \n", atof(arg3.data_d), atof(arg4.data_d), atof(arg5.data_d), atoi(arg0.data), atoi(arg1.data), base3, base4, base5, arg_idx[0], arg_idx[1], x_size, y_size, dx, dy);
		//OCL_CHECK(err, err = OPS_xcl_core.command_queue.enqueueTask(OPS_xcl_core.kernel[0]));
		ops_printf("Error value %d \n", err);
		OCL_CHECK(err, err = OPS_xcl_core.command_queue.finish());
		OCL_CHECK(err, err = OPS_xcl_core.command_queue.enqueueMigrateMemObjects({buff2, buff3, buff4}, CL_MIGRATE_MEM_OBJECT_HOST));
		ops_printf("BOSS3: arg0:%d, arg1:%d, base3:%d, base4:%d, base5:%d, arg_idx0:%d, arg_idx1:%d, size0:%d, size1:%d, dx:%f, dy:%f, arg3:%f, arg4:%f, arg5:%f \n", atoi(arg0.data), atoi(arg1.data), base3, base4, base5, arg_idx[0], arg_idx[1], x_size, y_size, dx, dy, atof(arg3.data_d), atof(arg4.data_d), atof(arg5.data_d));
		ops_printf("clEnqueueNDRangeKernel\n");
	}
	ops_printf("OPS_diags: %d \n", OPS_diags);
	if (OPS_diags>1) {
		//clSafeCall( clFinish(OPS_xcl_core.command_queue) );

		OCL_CHECK(err, err = OPS_xcl_core.command_queue.finish());
	}

	if (OPS_diags > 1) {
		ops_timers_core(&c1,&t1);
		OPS_kernels[0].time += t1-t2;
	}

	ops_set_dirtybit_device(args, 6);
	ops_set_halo_dirtybit3(&args[3],range);
	ops_set_halo_dirtybit3(&args[4],range);
	ops_set_halo_dirtybit3(&args[5],range);

	if (OPS_diags > 1) {
		//Update kernel record
		ops_timers_core(&c2,&t2);
		OPS_kernels[0].mpi_time += t2-t1;
		OPS_kernels[0].transfer += ops_compute_transfer(dim, start, end, &arg3);
		OPS_kernels[0].transfer += ops_compute_transfer(dim, start, end, &arg4);
		OPS_kernels[0].transfer += ops_compute_transfer(dim, start, end, &arg5);
	}
}
