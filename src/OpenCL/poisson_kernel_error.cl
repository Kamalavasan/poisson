//
// auto-generated by ops.py
//

#ifdef OCL_FMA
#pragma OPENCL FP_CONTRACT ON
#else
#pragma OPENCL FP_CONTRACT OFF
#endif
#pragma OPENCL EXTENSION cl_khr_fp64:enable

#include "user_types.h"
#define OPS_2D
#define OPS_API 2
#define OPS_NO_GLOBALS
#include "ops_macros.h"
#include "ops_opencl_reduction.h"

#ifndef MIN
#define MIN(a,b) ((a<b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a>b) ? (a) : (b))
#endif
#ifndef SIGN
#define SIGN(a,b) ((b<0.0) ? (a*(-1)) : (a))
#endif
#define OPS_READ 0
#define OPS_WRITE 1
#define OPS_RW 2
#define OPS_INC 3
#define OPS_MIN 4
#define OPS_MAX 5
#define ZERO_float 0.0;
#define INFINITY_float INFINITY;
#define ZERO_double 0.0f;
#define INFINITY_float INFINITY;
#define ZERO_int 0;
#define INFINITY_int INFINITY;
#define ZERO_uint 0;
#define INFINITY_uint INFINITY;
#define ZERO_ll 0;
#define INFINITY_ll INFINITY;
#define ZERO_ull 0;
#define INFINITY_ull INFINITY;
#define ZERO_bool 0;

//user function

/*void poisson_kernel_error(const ptr_float u,
		const ptr_float ref,
		float *err) {

	*err = *err + (OPS_ACCS(u, 0,0)-OPS_ACCS(ref, 0,0))*(OPS_ACCS(u, 0,0)-OPS_ACCS(ref, 0,0));
}*/


#define PORT_WIDTH 16
#define SHIFT_BITS 4
#define BEAT_SHIFT_BITS 11
#define BURST_LEN 128

__attribute__((xcl_dataflow))
__kernel __attribute__ ((reqd_work_group_size(1, 1, 1)))

__kernel void ops_poisson_kernel_error(
		__global const float16* restrict arg0,
		__global const float16* restrict arg1,
		__global float16* restrict arg2,
		__local float* scratch2,
		int r_bytes2,
		const int base0,
		const int base1,
		const int size0,
		const int size1,
		const int xdim0_poisson_kernel_error,
		const int xdim1_poisson_kernel_error){


	float g_sum = 0;

	local float16 mem_rd1[BURST_LEN+1];
	local float16 mem_rd2[BURST_LEN+1];

	float arr_focus[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1)));


	int beat_no = (size0 >> BEAT_SHIFT_BITS) + 1;

	int row_shift0 = 0;
	int row_shift1 = 0;
	for(int i  = 0; i < size1; i++){
			int base_index0, base_index1, loop_limit, adjust_burst, cond;

			v1_rd: __attribute__((xcl_pipeline_loop))
			for(int j = 0; j < beat_no ; j++){

				__attribute__((xcl_pipeline_workitems)){
					base_index0 = (base0  + row_shift0 + (j << BEAT_SHIFT_BITS) - 1) >> SHIFT_BITS;
					base_index1 = (base1  + row_shift1 + (j << BEAT_SHIFT_BITS) - 1) >> SHIFT_BITS;
					int cond = (size0 > ((j+1) << BEAT_SHIFT_BITS)) ? 1 : 0;
					int adjust_burst = ((size0 - (j << BEAT_SHIFT_BITS)) >> SHIFT_BITS) + 1;
					loop_limit = cond ? BURST_LEN : adjust_burst;
				}

				v1_row1_read: __attribute__((xcl_pipeline_loop))
				for(int k = 0; k < loop_limit; k++){
					mem_rd1[k] = arg0[base_index0 + k];
				}

				v2_row1_read: __attribute__((xcl_pipeline_loop))
				for(int k = 0; k < loop_limit; k++){
					mem_rd2[k] = arg1[base_index1 + k];
				}

				v3_process: __attribute__((xcl_pipeline_loop))
				for(int p = 0; p < loop_limit; p++){
					float16 tmp0 = mem_rd1[p];
					float16 tmp1 = mem_rd2[p];
					float16 diff = tmp0 -tmp1;

					float arr_diff[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1))) = {diff.s0, diff.s1, diff.s2, diff.s3, diff.s4, diff.s5, diff.s6, diff.s7,
							diff.s8, diff.s9, diff.sa, diff.sb, diff.sc, diff.sd, diff.se, diff.sf};


					__attribute__((xcl_pipeline_loop))
					__attribute__((opencl_unroll_hint(PORT_WIDTH)))
					for(int k = 0; k < PORT_WIDTH; k++){
						int index = (j << BEAT_SHIFT_BITS) + (p << SHIFT_BITS) + k;
						float square = arr_diff[k]* arr_diff[k];
						float eval = (index > size0 || index == 0) ? 0 : square;
						arr_focus[k] = arr_focus[k] + eval;
					}
				}
			}

			row_shift0  = row_shift0 + xdim0_poisson_kernel_error;
			row_shift1  = row_shift1 + xdim1_poisson_kernel_error;

		}

		float sum1[PORT_WIDTH/2] __attribute__((xcl_array_partition(complete, 1)));
		__attribute__((xcl_pipeline_loop))
		__attribute__((opencl_unroll_hint(PORT_WIDTH/2)))
		for(int k = 0; k < PORT_WIDTH/2; k++){
			sum1[k] = arr_focus[2*k] + arr_focus[2*k + 1];
		}

		float sum2[PORT_WIDTH/4] __attribute__((xcl_array_partition(complete, 1)));
		__attribute__((xcl_pipeline_loop))
		__attribute__((opencl_unroll_hint(PORT_WIDTH/4)))
		for(int k = 0; k < PORT_WIDTH/4; k++){
			sum2[k] = sum1[2*k] + sum1[2*k + 1];
		}

		float sum3 = sum2[0] + sum2[1];
		float sum4 = sum2[2] + sum2[3];
		float sum = sum3 + sum4;
		g_sum = g_sum + sum;

		arg2[r_bytes2 >> SHIFT_BITS] = (float16){g_sum, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0};

}
