//
// auto-generated by ops.py
//

#ifdef OCL_FMA
#pragma OPENCL FP_CONTRACT ON
#else
#pragma OPENCL FP_CONTRACT OFF
#endif
#pragma OPENCL EXTENSION cl_khr_fp64:enable

#include "user_types.h"
#define OPS_2D
#define OPS_API 2
#define OPS_NO_GLOBALS
#include "ops_macros.h"
#include "ops_opencl_reduction.h"

#ifndef MIN
#define MIN(a,b) ((a<b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a>b) ? (a) : (b))
#endif
#ifndef SIGN
#define SIGN(a,b) ((b<0.0) ? (a*(-1)) : (a))
#endif
#define OPS_READ 0
#define OPS_WRITE 1
#define OPS_RW 2
#define OPS_INC 3
#define OPS_MIN 4
#define OPS_MAX 5
#define ZERO_float 0.0;
#define INFINITY_float INFINITY;
#define ZERO_double 0.0f;
#define INFINITY_float INFINITY;
#define ZERO_int 0;
#define INFINITY_int INFINITY;
#define ZERO_uint 0;
#define INFINITY_uint INFINITY;
#define ZERO_ll 0;
#define INFINITY_ll INFINITY;
#define ZERO_ull 0;
#define INFINITY_ull INFINITY;
#define ZERO_bool 0;

//user function

/*void poisson_kernel_error(const ptr_float u,
		const ptr_float ref,
		float *err) {

	*err = *err + (OPS_ACCS(u, 0,0)-OPS_ACCS(ref, 0,0))*(OPS_ACCS(u, 0,0)-OPS_ACCS(ref, 0,0));
}*/


#define PORT_WIDTH 16
#define SHIFT_BITS 4

__kernel __attribute__ ((reqd_work_group_size(1, 1, 1)))

__kernel void ops_poisson_kernel_error(
		__global const float16* restrict arg0,
		__global const float16* restrict arg1,
		__global float16* restrict arg2,
		__local float* scratch2,
		int r_bytes2,
		const int base0,
		const int base1,
		const int size0,
		const int size1,
		const int xdim0_poisson_kernel_error,
		const int xdim1_poisson_kernel_error){


	float g_sum = 0;
	for(int i  = 0; i < size1; i++){
			int base_index0, base_index1, end_index;
			v1_index: __attribute__((xcl_pipeline_loop)){
				base_index0 = (base0  + i* xdim0_poisson_kernel_error - 1) >> SHIFT_BITS;
				base_index1 = (base1  + i* xdim0_poisson_kernel_error - 1) >> SHIFT_BITS;
				end_index = (xdim0_poisson_kernel_error >> SHIFT_BITS) + 1;
			}

			v1_rd: __attribute__((xcl_pipeline_loop))
			for(int j = 0; j < end_index ; j++){
				float16 tmp0 = arg0[base_index0+ j];
				float16 tmp1 = arg1[base_index1+ j];
				float16 diff = tmp0 -tmp1;

				float arr_diff[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1))) = {diff.s0, diff.s1, diff.s2, diff.s3, diff.s4, diff.s5, diff.s6, diff.s7,
						diff.s8, diff.s9, diff.sa, diff.sb, diff.sc, diff.sd, diff.se, diff.sf};

				float arr_focus[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1)));

				__attribute__((xcl_pipeline_loop))
				__attribute__((opencl_unroll_hint(PORT_WIDTH)))
				for(int k = 0; k < PORT_WIDTH; k++){
					int index = (j << SHIFT_BITS) + k;
					arr_focus[k] = (index > size0 || index == 0) ? 0 : arr_diff[k]* arr_diff[k];
				}

				float sum1[PORT_WIDTH/2] __attribute__((xcl_array_partition(complete, 1)));
				__attribute__((xcl_pipeline_loop))
				__attribute__((opencl_unroll_hint(PORT_WIDTH/2)))
				for(int k = 0; k < PORT_WIDTH/2; k++){
					sum1[k] = arr_focus[2*k] + arr_focus[2*k + 1];
				}

				float sum2[PORT_WIDTH/4] __attribute__((xcl_array_partition(complete, 1)));
				__attribute__((xcl_pipeline_loop))
				__attribute__((opencl_unroll_hint(PORT_WIDTH/2)))
				for(int k = 0; k < PORT_WIDTH/4; k++){
					sum2[k] = sum1[2*k] + sum1[2*k + 1];
				}

				float sum3 = sum2[0] + sum2[1];
				float sum4 = sum2[2] + sum2[3];
				float sum = sum3 + sum4;
				g_sum = g_sum + sum;
			}

		}

//	arg2[r_bytes2] = g_sum;
	arg2[r_bytes2 >> SHIFT_BITS] = (float16){g_sum, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0};

}
