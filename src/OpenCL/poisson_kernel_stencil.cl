//
// auto-generated by ops.py
//

#ifdef OCL_FMA
#pragma OPENCL FP_CONTRACT ON
#else
#pragma OPENCL FP_CONTRACT OFF
#endif
#pragma OPENCL EXTENSION cl_khr_fp64:enable

#include "user_types.h"
#define OPS_2D
#define OPS_API 2
#define OPS_NO_GLOBALS
#include "ops_macros.h"
#include "ops_opencl_reduction.h"

#ifndef MIN
#define MIN(a,b) ((a<b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a>b) ? (a) : (b))
#endif
#ifndef SIGN
#define SIGN(a,b) ((b<0.0) ? (a*(-1)) : (a))
#endif
#define OPS_READ 0
#define OPS_WRITE 1
#define OPS_RW 2
#define OPS_INC 3
#define OPS_MIN 4
#define OPS_MAX 5
#define ZERO_double 0.0;
#define INFINITY_double INFINITY;
#define ZERO_float 0.0f;
#define INFINITY_float INFINITY;
#define ZERO_int 0;
#define INFINITY_int INFINITY;
#define ZERO_uint 0;
#define INFINITY_uint INFINITY;
#define ZERO_ll 0;
#define INFINITY_ll INFINITY;
#define ZERO_ull 0;
#define INFINITY_ull INFINITY;
#define ZERO_bool 0;

//user function
#define PORT_WIDTH 16
#define SHIFT_BITS 4
#define BEAT_SHIFT_BITS 10
#define BURST_LEN 64

// FiX ME
#define MAX_SIZE_X 20000
#define MAX_DEPTH_16 (MAX_SIZE_X/16)


__constant int c_min_x = 40;
__constant int c_max_x = 8000;
__constant int c_avg_x = 8000;

__constant int c_min_size = c_min_x* c_min_x/16;
__constant int c_max_size = (c_max_x*c_max_x)/16;
__constant int c_avg_size = (c_avg_x*c_avg_x)/16;

__constant int c_min_beat = (c_min_x >> BEAT_SHIFT_BITS) + 1;
__constant int c_max_beat = (c_max_x >> BEAT_SHIFT_BITS) + 1;
__constant int c_avg_beat = (c_avg_x >> BEAT_SHIFT_BITS) + 1;

static void read_row(__global const float16* restrict arg0, float16* rd_buffer, const int xdim0_poisson_kernel_stencil, const int base0, int i, int beat){

	int base_index = (base0 + ((i-1) * xdim0_poisson_kernel_stencil) + (beat << BEAT_SHIFT_BITS) -1) >> SHIFT_BITS;
	read_row: __attribute__((xcl_pipeline_loop(1)))
	__attribute__((xcl_loop_tripcount(BURST_LEN+2, BURST_LEN+2, BURST_LEN+2)))
	for(int k =0; k < BURST_LEN+2; k++){
		rd_buffer[k] = arg0[base_index -1 + k];
	}
}

static void process_a_row(float16* rd_buffer, float16* wr_buffer, float16* row1, float16* row2, float16* row3, const int size0, const int xdim0_poisson_kernel_stencil, int beat){

	process_row: __attribute__((xcl_pipeline_loop(1)))
	__attribute__((xcl_loop_tripcount(BURST_LEN+2, BURST_LEN+2, BURST_LEN+2)))
	for(int j =0; j < BURST_LEN+2; j++){
		float16 tmp1_b1, tmp2_b1, tmp3_b1;
		float16 tmp1_b2, tmp2_b2, tmp3_b2;
		float16 tmp1, tmp2, tmp3;


		tmp1_b2 = tmp1_b1;
		tmp2_b2 = tmp2_b1;
		tmp3_b2 = tmp3_b1;

		tmp1_b1 = tmp1;
		tmp2_b1 = tmp2;
		tmp3_b1 = tmp3;

		tmp1 = rd_buffer[j];
		tmp2 = row1[j];
		tmp3 = row2[j];

		row1[j] = tmp1;
		row2[j] = tmp2;
		row3[j] = tmp3;

		float row_arr3[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1))) = {tmp1_b1.s0, tmp1_b1.s1, tmp1_b1.s2, tmp1_b1.s3, tmp1_b1.s4, tmp1_b1.s5, tmp1_b1.s6, tmp1_b1.s7,
										tmp1_b1.s8, tmp1_b1.s9, tmp1_b1.sa, tmp1_b1.sb, tmp1_b1.sc, tmp1_b1.sd, tmp1_b1.se, tmp1_b1.sf};

		float row_arr2[PORT_WIDTH + 2] __attribute__((xcl_array_partition(complete, 1))) = {tmp2_b2.sf, tmp2_b1.s0, tmp2_b1.s1, tmp2_b1.s2, tmp2_b1.s3, tmp2_b1.s4, tmp2_b1.s5, tmp2_b1.s6, tmp2_b1.s7,
										tmp2_b1.s8, tmp2_b1.s9, tmp2_b1.sa, tmp2_b1.sb, tmp2_b1.sc, tmp2_b1.sd, tmp2_b1.se, tmp2_b1.sf, tmp2.s0};

		float row_arr1[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1))) = {tmp3_b1.s0, tmp3_b1.s1, tmp3_b1.s2, tmp3_b1.s3, tmp3_b1.s4, tmp3_b1.s5, tmp3_b1.s6, tmp3_b1.s7,
						tmp3_b1.s8, tmp3_b1.s9, tmp3_b1.sa, tmp3_b1.sb, tmp3_b1.sc, tmp3_b1.sd, tmp3_b1.se, tmp3_b1.sf};

		float mem_wr[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1)));

		process: for(int q = 0; q < PORT_WIDTH; q++){
			int index = (beat << BEAT_SHIFT_BITS) + (j << SHIFT_BITS) + q - 32;
			float f1 = ( row_arr2[q]  + row_arr2[q+2] ) * 0.125f;
			float f2 = ( row_arr1[q]  + row_arr3[q] ) * 0.125f;
			float f3 = row_arr2[q+1] * 0.5f;
			float result  = f1 + f2 + f3;
			mem_wr[q] = (index <= 0 || index > size0) ? row_arr2[q+1] : result;
		}
		float16 update_j = (float16) {mem_wr[0], mem_wr[1], mem_wr[2], mem_wr[3], mem_wr[4], mem_wr[5], mem_wr[6], mem_wr[7],
											mem_wr[8], mem_wr[9], mem_wr[10], mem_wr[11], mem_wr[12], mem_wr[13], mem_wr[14], mem_wr[15]};

		if(j >= 2) wr_buffer[j-2] = update_j;
	}
}

static void write_row(__global  float16* restrict arg1, float16* wr_buffer, const int xdim1_poisson_kernel_stencil, const int base1, int i, int beat){
	int base_index = (base1 + ((i-2) * xdim1_poisson_kernel_stencil) + (beat << BEAT_SHIFT_BITS) -1) >> SHIFT_BITS;
	if(i >= 2){
		write_row: __attribute__((xcl_pipeline_loop(1)))
		__attribute__((xcl_loop_tripcount(BURST_LEN, BURST_LEN, BURST_LEN)))
		for(int k =0; k < BURST_LEN; k++){
			arg1[base_index + k] = wr_buffer[k];
		}
	}
}


__attribute__((xcl_dataflow))
void process(__global const float16* restrict arg0, __global float16* restrict arg1, const int xdim0_poisson_kernel_stencil, const int base0, const int xdim1_poisson_kernel_stencil, const int base1, const int size0, int i, int beat){

	float16 row1[BURST_LEN + 2];
	float16 row2[BURST_LEN + 2];
	float16 row3[BURST_LEN + 2];

	float16 wr_buffer[BURST_LEN];
	float16 rd_buffer[BURST_LEN + 2];

	read_row(arg0, rd_buffer, xdim0_poisson_kernel_stencil, base0, i, beat);
	process_a_row(rd_buffer, wr_buffer, row1, row2, row3, size0, xdim0_poisson_kernel_stencil, beat);
	write_row(arg1, wr_buffer, xdim1_poisson_kernel_stencil, base1, i, beat);
}


__kernel __attribute__ ((reqd_work_group_size(1, 1, 1)))
__kernel void ops_poisson_kernel_stencil(
		__global const float16* restrict arg0,
		__global float16* restrict arg1,
		const int base0,
		const int base1,
		const int size0,
		const int size1,
		const int xdim0_poisson_kernel_stencil,
		const int xdim1_poisson_kernel_stencil){


	int end_row  = size1+2;
	int beats = (xdim0_poisson_kernel_stencil >> BEAT_SHIFT_BITS) + 1;

	__attribute__((xcl_dataflow))
	__attribute__((xcl_loop_tripcount(c_min_x * c_min_beat, c_max_x * c_max_beat, c_avg_x * c_max_beat)))
	loop_beats: for(int itr = 0, i = 0 ,beat = 0; itr < beats * end_row; itr++){
		int beat = itr / end_row;
		int i = itr % end_row;
		process(arg0, arg1, xdim0_poisson_kernel_stencil, base0, xdim0_poisson_kernel_stencil, base0, size0, i, beat);
	}
}
