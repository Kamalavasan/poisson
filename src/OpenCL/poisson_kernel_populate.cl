//
// auto-generated by ops.py
//

#ifdef OCL_FMA
#pragma OPENCL FP_CONTRACT ON
#else
#pragma OPENCL FP_CONTRACT OFF
#endif
#pragma OPENCL EXTENSION cl_khr_fp64:enable

#include "user_types.h"
#define OPS_2D
#define OPS_API 2
#define OPS_NO_GLOBALS
#include "ops_macros.h"
#include "ops_opencl_reduction.h"

#ifndef MIN
#define MIN(a,b) ((a<b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a>b) ? (a) : (b))
#endif
#ifndef SIGN
#define SIGN(a,b) ((b<0.0) ? (a*(-1)) : (a))
#endif
#define OPS_READ 0
#define OPS_WRITE 1
#define OPS_RW 2
#define OPS_INC 3
#define OPS_MIN 4
#define OPS_MAX 5
#define ZERO_double 0.0;
#define INFINITY_double INFINITY;
#define ZERO_float 0.0f;
#define INFINITY_float INFINITY;
#define ZERO_int 0;
#define INFINITY_int INFINITY;
#define ZERO_uint 0;
#define INFINITY_uint INFINITY;
#define ZERO_ll 0;
#define INFINITY_ll INFINITY;
#define ZERO_ull 0;
#define INFINITY_ull INFINITY;
#define ZERO_bool 0;


#define SHIFT_BITS 4
#define PORT_WIDTH 16
#define BEAT_SHIFT_BITS 11
#define BURST_LEN 128

__kernel __attribute__((xcl_dataflow))
__kernel __attribute__ ((reqd_work_group_size(1, 1, 1)))

__kernel void ops_poisson_kernel_populate(
		const int arg0,
		const int arg1,
		__global float16* restrict arg3,
		__global float16* restrict arg4,
		__global float16* restrict arg5,
		const float dx,
		const float dy,
		const int base3,
		const int base4,
		const int base5,
		int arg_idx0, int arg_idx1,
		const int size0,
		const int size1,
		const int xdim3_poisson_kernel_populate,
		const int xdim4_poisson_kernel_populate,
		const int xdim5_poisson_kernel_populate){


		int beat_no = (size0 >> BEAT_SHIFT_BITS) + 1;
		local float mem3[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1)));
		local float mem4[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1)));
		local float mem5[PORT_WIDTH] __attribute__((xcl_array_partition(complete, 1)));

		local float16 mem3_16[BURST_LEN];
		local float16 mem4_16[BURST_LEN];
		local float16 mem5_16[BURST_LEN];


		// arg3
		for(int i  = 0; i < size1; i++){
			int arg_idx[2];
			double x, y;
			int base_index3, base_index4, base_index5, loop_limit;

			__attribute__((xcl_pipeline_workitems)){
				base_index3 = (base3 +  i* xdim3_poisson_kernel_populate) >> SHIFT_BITS;
				arg_idx[1] = arg_idx1+ i;
			}

			for(int j = 0; j < beat_no; j++){

				__attribute__((xcl_pipeline_workitems)){
					base_index3 = (base3  + i* xdim3_poisson_kernel_populate + (j << BEAT_SHIFT_BITS)) >> SHIFT_BITS;
					base_index4 = (base4  + i* xdim4_poisson_kernel_populate + (j << BEAT_SHIFT_BITS)) >> SHIFT_BITS;
					base_index5 = (base5  + i* xdim5_poisson_kernel_populate + (j << BEAT_SHIFT_BITS)) >> SHIFT_BITS;
					int cond = (size0 > ((j+1) << BEAT_SHIFT_BITS)) ? 1 : 0;
					int adjust_burst = ((size0 - (j << BEAT_SHIFT_BITS)) >> SHIFT_BITS) + 1;
					loop_limit = cond ? BURST_LEN : adjust_burst;
				}

				main_process: __attribute__((xcl_pipeline_loop))
				for(int p = 0; p < loop_limit; p++){

					v345_process: __attribute__((xcl_pipeline_loop))
					__attribute__((opencl_unroll_hint(PORT_WIDTH)))
					for(int k = 0; k < PORT_WIDTH; k++){
						int index_x = (j << BEAT_SHIFT_BITS) + (p << SHIFT_BITS) + k;

						arg_idx[0] = arg_idx0+ index_x;

						x = dx * (double)(arg_idx[0]+arg0);
						y = dy * (double)(arg_idx[1]+arg1);

						float f3 = myfun(native_sin(M_PI*x),native_cos(2.0*M_PI*y))-1.0;
						float f4 = -5.0*M_PI*M_PI*native_sin(M_PI*x)*native_cos(2.0*M_PI*y);
						float f5 = native_sin(M_PI*x)*native_cos(2.0*M_PI*y);
						mem3[k] = f3;
						mem4[k] = f4;
						mem5[k] = f5;
					}
					mem3_16[p] = (float16) {mem3[0], mem3[1], mem3[2], mem3[3], mem3[4], mem3[5], mem3[6], mem3[7], mem3[8], mem3[9], mem3[10], mem3[11], mem3[12], mem3[13], mem3[14], mem3[15]};
					mem4_16[p] = (float16) {mem4[0], mem4[1], mem4[2], mem4[3], mem4[4], mem4[5], mem4[6], mem4[7], mem4[8], mem4[9], mem4[10], mem4[11], mem4[12], mem4[13], mem4[14], mem4[15]};
					mem5_16[p] = (float16) {mem5[0], mem5[1], mem5[2], mem5[3], mem5[4], mem5[5], mem5[6], mem5[7], mem5[8], mem5[9], mem5[10], mem5[11], mem5[12], mem5[13], mem5[14], mem5[15]};


				}
				v3_wr: __attribute__((xcl_pipeline_loop))
				for(int p = 0; p < loop_limit; p++){
					arg3[base_index3 +p] = mem3_16[p];
				}

				v4_wr: __attribute__((xcl_pipeline_loop))
				for(int p = 0; p < loop_limit; p++){
					arg4[base_index4 +p] = mem4_16[p];
				}

				v5_wr: __attribute__((xcl_pipeline_loop))
				for(int p = 0; p < loop_limit; p++){
					arg5[base_index5 +p] = mem5_16[p];
				}
			}
		}


}
